/**
 * @file max_clique_random_neighborhood.cpp
 * @brief 最大クリーク問題：ランダムシード近傍探索 (Hybrid approach)
 * @details ランダムに頂点を選び、その近傍（部分グラフ）を生成して貪欲法を行う。
 */

// --- ヘッダファイルのインクルード ---
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_set>
#include <random>
#include <chrono>
#include <fstream>
#include <string>
#include <sstream>
#include <mutex>
#include <thread>
#include <iomanip>

#include "taskflow.hpp"

// --- Graphクラス ---
class Graph {
private:
    int num_vertices_;
    std::vector<std::unordered_set<int>> adj_list_;

public:
    Graph(int vertices) : num_vertices_(vertices), adj_list_(vertices) {}

    int get_num_vertices() const { return num_vertices_; }

    void add_edge(int u, int v) {
        if (u >= 0 && u < num_vertices_ && v >= 0 && v < num_vertices_) {
            adj_list_[u].insert(v);
            adj_list_[v].insert(u);
        }
    }

    bool is_adjacent(int u, int v) const {
        return adj_list_[u].count(v);
    }

    int get_degree(int u) const {
        return (u >= 0 && u < num_vertices_) ? adj_list_[u].size() : 0;
    }

    // ★重要: 指定した頂点の「近傍（隣接している頂点）」だけを返す
    // これが「BFSで小さな部分グラフを作る」操作に相当します
    std::vector<int> get_neighbors(int u) const {
        if (u < 0 || u >= num_vertices_) return {};
        std::vector<int> neighbors(adj_list_[u].begin(), adj_list_[u].end());
        return neighbors;
    }

    // 部分集合の中での貪欲法（次数順）
    std::vector<int> find_greedy_clique_in_subset(std::vector<int>& candidates) const {
        // 部分グラフ内での有望度（元のグラフでの次数）順にソート
        std::sort(candidates.begin(), candidates.end(), [this](int a, int b) {
            return adj_list_[a].size() > adj_list_[b].size();
        });

        std::vector<int> clique;
        clique.reserve(candidates.size());

        for (int u : candidates) {
            bool can_add = true;
            for (int v : clique) {
                if (!is_adjacent(u, v)) {
                    can_add = false;
                    break;
                }
            }
            if (can_add) {
                clique.push_back(u);
            }
        }
        return clique;
    }
};

// --- DIMACS読み込み関数 ---
Graph load_dimacs_graph(const std::string& filename) {
    std::ifstream ifs(filename);
    if (!ifs) {
        std::cerr << "Error: Could not open file " << filename << std::endl;
        exit(1);
    }
    std::string line;
    int num_vertices = 0;
    while (std::getline(ifs, line)) {
        if (line.empty() || line[0] == 'c') continue;
        if (line[0] == 'p') {
            std::stringstream ss(line);
            std::string temp;
            ss >> temp >> temp >> num_vertices;
            break;
        }
    }
    if (num_vertices == 0) exit(1);
    std::cout << "Loading DIMACS graph: " << filename << " (Vertices: " << num_vertices << ")" << std::endl;
    Graph g(num_vertices);
    while (std::getline(ifs, line)) {
        if (line.empty() || line[0] == 'c') continue;
        std::stringstream ss(line);
        char type; 
        int u, v;
        if (line[0] == 'e') ss >> type >> u >> v;
        else { std::stringstream tss(line); if(!(tss >> u >> v)) continue; }
        if (u > 0) u--; if (v > 0) v--;
        g.add_edge(u, v);
    }
    return g;
}

// --- メイン関数 ---
int main() {
    const std::string filename = "C500.9.clq"; 
    // const std::string filename = "C2000.5.clq"; // 大きなグラフでも試せます
    
    std::cout << "Reading graph..." << std::endl;
    Graph graph = load_dimacs_graph(filename);

    std::cout << "Starting parallel RANDOM NEIGHBORHOOD search..." << std::endl;

    tf::Executor executor;
    tf::Taskflow taskflow;

    std::vector<int> best_clique;
    std::mutex mtx;
    
    int total_vertices = graph.get_num_vertices();

    // ★試行回数
    // ランダムなので、頂点数より多く回すことで、良いスタート地点を何度も引くチャンスを作ります。
    // 重い場合は減らしてください。
    const int num_trials = 100000; 

    std::cout << "Trials: " << num_trials << std::endl;

    auto start_time = std::chrono::high_resolution_clock::now();

    // 並列ループ生成
    for (int i = 0; i < num_trials; ++i) {
        taskflow.emplace([&]() {
            // 1. ランダムな点（シード）を決める
            // スレッドごとに乱数生成器を作るのがポイント
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> dist(0, total_vertices - 1);
            
            int seed_vertex = dist(gen);

            // 2. 幅優先探索（深さ1）を行い、小さな部分グラフを作る
            // シード頂点の近傍を取得
            std::vector<int> subgraph_nodes = graph.get_neighbors(seed_vertex);

            // 3. その中で最大クリークを探す（貪欲法）
            // シード頂点自体も候補に加えるか、または最後に追加する
            // ここでは探索関数が候補リストを受け取るので、候補リストだけで探させる
            std::vector<int> local_clique = graph.find_greedy_clique_in_subset(subgraph_nodes);

            // シード頂点は必ずその近傍全員と繋がっているので、最後に無条件で追加できる
            local_clique.push_back(seed_vertex);

            // 4. 結果更新
            if (local_clique.size() > best_clique.size()) {
                std::lock_guard<std::mutex> lock(mtx);
                if (local_clique.size() > best_clique.size()) {
                    best_clique = std::move(local_clique);
                }
            }
        });
    }

    executor.run(taskflow).wait();

    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);

    // --- 結果出力 ---
    std::cout << "\n--- Result ---" << std::endl;
    std::cout << "Best clique size found: " << best_clique.size() << std::endl;
    std::cout << "Time: " << duration.count() << " ms" << std::endl;

    std::cout << "Clique vertices: ";
    std::sort(best_clique.begin(), best_clique.end());
    for (size_t i = 0; i < best_clique.size(); ++i) {
        std::cout << (best_clique[i] + 1) << " ";
    }
    std::cout << std::endl;

    return 0;
}